{"version":3,"file":"ldclient.es.js","sources":["../src/errors.js","../node_modules/Base64/base64.js","../src/utils.js","../src/EventSender.js","../src/EventSummarizer.js","../src/messages.js","../src/UserFilter.js","../src/EventProcessor.js","../src/EventEmitter.js","../node_modules/escape-string-regexp/index.js","../src/GoalTracker.js","../src/Store.js","../src/Stream.js","../src/Requestor.js","../src/Identity.js","../src/index.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n",";(function () {\n\n  var object =\n    typeof exports != 'undefined' ? exports :\n    typeof self != 'undefined' ? self : // #8: web workers\n    $.global; // #31: ExtendScript\n\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    var str = String(input);\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next str index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      str.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = str.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    var str = String(input).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=\n    if (str.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n","import Base64 from 'Base64';\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  return Base64.btoa(unescape(encodeURIComponent(s)));\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (flags.hasOwnProperty(key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (flagsState.hasOwnProperty(key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString() {\n  return 'JSClient/' + VERSION;\n}\n\nexport function addLDHeaders(xhr) {\n  xhr.setRequestHeader('X-LaunchDarkly-User-Agent', getLDUserAgentString());\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n","import * as errors from './errors';\nimport * as utils from './utils';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(eventsUrl, environmentId, forceHasCors, imageCreator, sendLDHeaders = true) {\n  let hasCors;\n  const postUrl = eventsUrl + '/events/bulk/' + environmentId;\n  const imageUrl = eventsUrl + '/a/' + environmentId + '.gif';\n  const sender = {};\n\n  function loadUrlUsingImage(src, onDone) {\n    const img = new Image();\n    if (onDone) {\n      img.addEventListener('load', onDone);\n    }\n    img.src = src;\n  }\n\n  function getResponseInfo(xhr) {\n    const ret = { status: xhr.status };\n    const dateStr = xhr.getResponseHeader('Date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  function sendChunk(events, usePost, sync) {\n    const createImage = imageCreator || loadUrlUsingImage;\n    const jsonBody = JSON.stringify(events);\n    const send = onDone => {\n      function createRequest(canRetry) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', postUrl, !sync);\n        if (sendLDHeaders) {\n          utils.addLDHeaders(xhr);\n        }\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.setRequestHeader('X-LaunchDarkly-Event-Schema', '3');\n        if (!sync) {\n          xhr.addEventListener('load', () => {\n            if (xhr.status >= 400 && errors.isHttpErrorRecoverable(xhr.status) && canRetry) {\n              createRequest(false).send(jsonBody);\n            } else {\n              onDone(getResponseInfo(xhr));\n            }\n          });\n          if (canRetry) {\n            xhr.addEventListener('error', () => {\n              createRequest(false).send(jsonBody);\n            });\n          }\n        }\n        return xhr;\n      }\n      if (usePost) {\n        createRequest(true).send(jsonBody);\n      } else {\n        const src = imageUrl + '?d=' + utils.base64URLEncode(jsonBody);\n        createImage(src, sync ? null : onDone);\n      }\n    };\n\n    if (sync) {\n      send();\n    } else {\n      return new Promise(resolve => {\n        send(resolve);\n      });\n    }\n  }\n\n  sender.sendEvents = function(events, sync) {\n    // Detect browser support for CORS (can be overridden by tests)\n    if (hasCors === undefined) {\n      if (forceHasCors === undefined) {\n        hasCors = 'withCredentials' in new XMLHttpRequest();\n      } else {\n        hasCors = forceHasCors;\n      }\n    }\n\n    const finalSync = sync === undefined ? false : sync;\n    let chunks;\n    if (hasCors) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - eventsUrl.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sendChunk(chunks[i], hasCors, finalSync));\n    }\n    return sync ? Promise.resolve() : Promise.all(results);\n  };\n\n  return sender;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","const docLink =\n  ' Please see https://docs.launchdarkly.com/docs/js-sdk-reference#section-initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function() {\n  return 'localStorage is unavailable';\n};\n\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'environment not found.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + (err.message || err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  return '[LaunchDarkly] \"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n","import * as messages from './messages';\nimport * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate =\n    config.allAttributesPrivate !== undefined ? config.allAttributesPrivate : config.all_attributes_private;\n  const privateAttributeNames =\n    (config.privateAttributeNames !== undefined ? config.privateAttributeNames : config.private_attribute_names) || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  if (config.all_attributes_private !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('all_attributes_private', 'allAttributesPrivate'));\n  }\n  if (config.private_attribute_names !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('private_attribute_names', 'privateAttributeNames'));\n  }\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(\n  eventsUrl,\n  environmentId,\n  options = {},\n  emitter = null,\n  sender = null,\n  sendLDHeaders\n) {\n  const processor = {};\n  const eventSender = sender || EventSender(eventsUrl, environmentId, sendLDHeaders);\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = !!options.inlineUsersInEvents;\n  let queue = [];\n  let flushInterval;\n  let samplingInterval;\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let flushTimer;\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  if (options.samplingInterval !== undefined && (isNaN(options.samplingInterval) || options.samplingInterval < 0)) {\n    samplingInterval = 0;\n    reportArgumentError('Invalid sampling interval configured. Sampling interval must be an integer >= 0.');\n  } else {\n    samplingInterval = options.samplingInterval || 0;\n  }\n\n  if (options.flushInterval !== undefined && (isNan(options.flushInterval) || options.flushInterval < 2000)) {\n    flushInterval = 2000;\n    reportArgumentError('Invalid flush interval configured. Must be an integer >= 2000 (milliseconds).');\n  } else {\n    flushInterval = options.flushInterval || 2000;\n  }\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      queue.push(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      delete debugEvent['variation'];\n      queue.push(debugEvent);\n    }\n  };\n\n  processor.flush = function(sync) {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    return eventSender.sendEvents(eventsToSend, sync).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventEmitter() {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      events[event][i].handler.apply(events[event][i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      console.error(error.message);\n    }\n  };\n  return emitter;\n}\n","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n","import escapeStringRegexp from 'escape-string-regexp';\n\nfunction doesUrlMatch(matcher, href, search, hash) {\n  const canonicalUrl = href.replace(search, '').replace(hash, '');\n  let regex;\n  let testUrl;\n\n  switch (matcher.kind) {\n    case 'exact':\n      testUrl = href;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'canonical':\n      testUrl = canonicalUrl;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'substring':\n      testUrl = canonicalUrl;\n      regex = new RegExp('.*' + escapeStringRegexp(matcher.substring) + '.*$');\n      break;\n    case 'regex':\n      testUrl = canonicalUrl;\n      regex = new RegExp(matcher.pattern);\n      break;\n    default:\n      return false;\n  }\n  return regex.test(testUrl);\n}\n\nfunction findGoalsForClick(event, clickGoals) {\n  const matches = [];\n\n  for (let i = 0; i < clickGoals.length; i++) {\n    let target = event.target;\n    const goal = clickGoals[i];\n    const selector = goal.selector;\n    const elements = document.querySelectorAll(selector);\n    while (target && elements.length > 0) {\n      for (let j = 0; j < elements.length; j++) {\n        if (target === elements[j]) {\n          matches.push(goal);\n        }\n      }\n      target = target.parentNode;\n    }\n  }\n\n  return matches;\n}\n\nexport default function GoalTracker(goals, onEvent) {\n  const tracker = {};\n  let listenerFn = null;\n\n  const clickGoals = [];\n\n  for (let i = 0; i < goals.length; i++) {\n    const goal = goals[i];\n    const urls = goal.urls || [];\n\n    for (let j = 0; j < urls.length; j++) {\n      if (doesUrlMatch(urls[j], location.href, location.search, location.hash)) {\n        if (goal.kind === 'pageview') {\n          onEvent('pageview', goal);\n        } else {\n          clickGoals.push(goal);\n          onEvent('click_pageview', goal);\n        }\n        break;\n      }\n    }\n  }\n\n  if (clickGoals.length > 0) {\n    listenerFn = function(event) {\n      const goals = findGoalsForClick(event, clickGoals);\n      for (let i = 0; i < goals.length; i++) {\n        onEvent('click', goals[i]);\n      }\n    };\n\n    document.addEventListener('click', listenerFn);\n  }\n\n  tracker.dispose = function() {\n    document.removeEventListener('click', listenerFn);\n  };\n\n  return tracker;\n}\n","import * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function Store(environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  store.loadFlags = function() {\n    const key = getFlagsKey();\n    let dataStr, data;\n    try {\n      dataStr = localStorage.getItem(key);\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n      return null;\n    }\n    try {\n      data = JSON.parse(dataStr);\n    } catch (ex) {\n      store.clearFlags();\n      return null;\n    }\n    if (data) {\n      const schema = data.$schema;\n      if (schema === undefined || schema < 1) {\n        data = utils.transformValuesToVersionedValues(data);\n      }\n    }\n    return data;\n  };\n\n  store.saveFlags = function(flags) {\n    const key = getFlagsKey();\n    const data = utils.extend({}, flags, { $schema: 1 });\n    try {\n      localStorage.setItem(key, JSON.stringify(data));\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n    }\n  };\n\n  store.clearFlags = function() {\n    const key = getFlagsKey();\n    try {\n      localStorage.removeItem(key);\n    } catch (ex) {}\n  };\n\n  return store;\n}\n","import { base64URLEncode } from './utils';\n\nexport default function Stream(baseUrl, environment, hash, config) {\n  const stream = {};\n  const evalUrlPrefix = baseUrl + '/eval/' + environment + '/';\n  const useReport = (config && config.useReport) || false;\n  const withReasons = (config && config.evaluationReasons) || false;\n  const streamReconnectDelay = (config && config.streamReconnectDelay) || 1000;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let user = null;\n  let handlers = null;\n\n  stream.connect = function(newUser, newHandlers) {\n    user = newUser;\n    handlers = newHandlers;\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    close();\n  };\n\n  stream.isConnected = function() {\n    return es && (es.readyState === EventSource.OPEN || es.readyState === EventSource.CONNECTING);\n  };\n\n  function reconnect() {\n    closeConnection();\n    tryConnect(streamReconnectDelay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    let url;\n    let query = '';\n    if (typeof EventSource !== 'undefined') {\n      if (useReport) {\n        // we don't yet have an EventSource implementation that supports REPORT, so\n        // fall back to the old ping-based stream\n        url = baseUrl + '/ping/' + environment;\n      } else {\n        url = evalUrlPrefix + base64URLEncode(JSON.stringify(user));\n        if (hash !== null && hash !== undefined) {\n          query = 'h=' + hash;\n        }\n      }\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      es = new window.EventSource(url);\n      for (const key in handlers) {\n        if (handlers.hasOwnProperty(key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = reconnect;\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      es.close();\n      es = null;\n    }\n  }\n\n  return stream;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\n\nconst json = 'application/json';\n\nfunction fetchJSON(endpoint, body, callback, sendLDHeaders) {\n  const xhr = new XMLHttpRequest();\n  let data = undefined;\n\n  xhr.addEventListener('load', () => {\n    if (\n      xhr.status === 200 &&\n      xhr.getResponseHeader('Content-type') &&\n      xhr.getResponseHeader('Content-Type').lastIndexOf(json) === 0\n    ) {\n      callback(null, JSON.parse(xhr.responseText));\n    } else {\n      callback(getResponseError(xhr));\n    }\n  });\n\n  xhr.addEventListener('error', () => {\n    callback(getResponseError(xhr));\n  });\n\n  if (body) {\n    xhr.open('REPORT', endpoint);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    data = JSON.stringify(body);\n  } else {\n    xhr.open('GET', endpoint);\n  }\n\n  if (sendLDHeaders) {\n    utils.addLDHeaders(xhr);\n  }\n\n  xhr.send(data);\n\n  return xhr;\n}\n\nfunction getResponseError(xhr) {\n  if (xhr.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return xhr.statusText;\n  }\n}\n\nexport default function Requestor(baseUrl, environment, useReport, withReasons, sendLDHeaders) {\n  let flagSettingsRequest;\n  let lastFlagSettingsCallback;\n\n  const requestor = {};\n\n  requestor.fetchFlagSettings = function(user, hash, callback) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n    let cb;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = user;\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n\n    const wrappedCallback = (function(currentCallback) {\n      return function(error, result) {\n        currentCallback(error, result);\n        flagSettingsRequest = null;\n        lastFlagSettingsCallback = null;\n      };\n    })(callback);\n\n    if (flagSettingsRequest) {\n      flagSettingsRequest.abort();\n      cb = (function(prevCallback) {\n        return function() {\n          prevCallback && prevCallback.apply(null, arguments);\n          wrappedCallback.apply(null, arguments);\n        };\n      })(lastFlagSettingsCallback);\n    } else {\n      cb = wrappedCallback;\n    }\n\n    lastFlagSettingsCallback = cb;\n    flagSettingsRequest = fetchJSON(endpoint, body, cb, sendLDHeaders);\n  };\n\n  requestor.fetchGoals = function(callback) {\n    const endpoint = [baseUrl, '/sdk/goals/', environment].join('');\n    fetchJSON(endpoint, null, callback, sendLDHeaders);\n  };\n\n  return requestor;\n}\n","import * as utils from './utils';\n\nfunction sanitizeUser(u) {\n  const sane = utils.clone(u);\n  if (sane.key) {\n    sane.key = sane.key.toString();\n  }\n  return sane;\n}\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    user = sanitizeUser(u);\n    onChange(utils.clone(user));\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport GoalTracker from './GoalTracker';\nimport Store from './Store';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport * as utils from './utils';\nimport * as messages from './messages';\nimport * as errors from './errors';\n\nconst readyEvent = 'ready';\nconst successEvent = 'initialized';\nconst failedEvent = 'failed';\nconst changeEvent = 'change';\nconst goalsEvent = 'goalsReady';\nconst locationWatcherInterval = 300;\n\nexport function initialize(env, user, options = {}) {\n  const baseUrl = options.baseUrl || 'https://app.launchdarkly.com';\n  const eventsUrl = options.eventsUrl || 'https://events.launchdarkly.com';\n  const streamUrl = options.streamUrl || 'https://clientstream.launchdarkly.com';\n  const hash = options.hash;\n  const sendEvents = optionWithDefault('sendEvents', true);\n  const sendLDHeaders = optionWithDefault('sendLDHeaders', true);\n  const allowFrequentDuplicateEvents = !!options.allowFrequentDuplicateEvents;\n  const sendEventsOnlyForVariation = !!options.sendEventsOnlyForVariation;\n  const fetchGoals = typeof options.fetchGoals === 'undefined' ? true : options.fetchGoals;\n  const environment = env;\n  const emitter = EventEmitter();\n  const stream = Stream(streamUrl, environment, hash, options);\n  const events =\n    options.eventProcessor || EventProcessor(eventsUrl, environment, options, emitter, null, sendLDHeaders);\n  const requestor = Requestor(baseUrl, environment, options.useReport, options.evaluationReasons, sendLDHeaders);\n  const seenRequests = {};\n  let flags = typeof options.bootstrap === 'object' ? readFlagsFromBootstrap(options.bootstrap) : {};\n  let goalTracker;\n  let useLocalStorage;\n  let goals;\n  let subscribedToChangeEvents;\n  let firstEvent = true;\n\n  function optionWithDefault(name, defaultVal) {\n    return typeof options[name] === 'undefined' ? defaultVal : options[name];\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      console.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      console.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !doNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!event.user) {\n      if (firstEvent) {\n        if (console && console.warn) {\n          console.warn(\n            'Be sure to call `identify` in the LaunchDarkly client: http://docs.launchdarkly.com/docs/running-an-ab-test#include-the-client-side-snippet'\n          );\n        }\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n    if (shouldEnqueueEvent()) {\n      events.enqueue(event);\n    }\n  }\n\n  function sendIdentifyEvent(user) {\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  const ident = Identity(user, sendIdentifyEvent);\n  const store = Store(environment, hash, ident);\n\n  function sendFlagEvent(key, detail, defaultValue) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n    if (!allowFrequentDuplicateEvents) {\n      const cacheKey = JSON.stringify(value) + (user && user.key ? user.key : '') + key; // see below\n      const cached = seenRequests[cacheKey];\n      // cache TTL is five minutes\n      if (cached && now - cached < 300000) {\n        return;\n      }\n      seenRequests[cacheKey] = now;\n    }\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n      reason: detail ? detail.reason : null,\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function sendGoalEvent(kind, goal) {\n    const event = {\n      kind: kind,\n      key: goal.key,\n      data: null,\n      url: window.location.href,\n      user: ident.getUser(),\n      creationDate: new Date().getTime(),\n    };\n\n    if (kind === 'click') {\n      event.selector = goal.selector;\n    }\n\n    return enqueueEvent(event);\n  }\n\n  function identify(user, hash, onDone) {\n    if (useLocalStorage) {\n      store.clearFlags();\n    }\n    return utils.wrapPromiseCallback(\n      new Promise((resolve, reject) => {\n        if (!user || user.key === null || user.key === undefined) {\n          const err = new errors.LDInvalidUserError(user ? messages.invalidUser() : messages.userNotSpecified());\n          emitter.maybeReportError(err);\n          reject(err);\n        } else {\n          ident.setUser(user);\n          requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n            if (err) {\n              emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n              return reject(err);\n            }\n            if (settings) {\n              updateSettings(settings);\n            }\n            resolve(utils.transformVersionedValuesToValues(settings));\n            if (subscribedToChangeEvents) {\n              connectStream();\n            }\n          });\n        }\n      }),\n      onDone\n    );\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(\n      new Promise(resolve => (sendEvents ? resolve(events.flush()) : resolve()), onDone)\n    );\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent) {\n    let detail;\n\n    if (flags && flags.hasOwnProperty(key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function doNotTrack() {\n    let flag;\n    if (navigator && navigator.doNotTrack !== undefined) {\n      flag = navigator.doNotTrack; // FF, Chrome\n    } else if (navigator && navigator.msDoNotTrack !== undefined) {\n      flag = navigator.msDoNotTrack; // IE 9/10\n    } else {\n      flag = window.doNotTrack; // IE 11+, Safari\n    }\n    return flag === '1' || flag === 'yes';\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key)) {\n        results[key] = variationDetailInternal(key, null, !sendEventsOnlyForVariation).value;\n      }\n    }\n\n    return results;\n  }\n\n  function customEventExists(key) {\n    if (!goals || goals.length === 0) {\n      return false;\n    }\n\n    for (let i = 0; i < goals.length; i++) {\n      if (goals[i].kind === 'custom' && goals[i].key === key) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function track(key, data) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    // Validate key if we have goals\n    if (!!goals && !customEventExists(key)) {\n      console.warn(messages.unknownCustomEventKey(key));\n    }\n\n    enqueueEvent({\n      kind: 'custom',\n      key: key,\n      data: data,\n      user: ident.getUser(),\n      url: window.location.href,\n      creationDate: new Date().getTime(),\n    });\n  }\n\n  function connectStream() {\n    if (!ident.getUser()) {\n      return;\n    }\n    stream.connect(ident.getUser(), {\n      ping: function() {\n        requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n          if (err) {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          }\n          updateSettings(settings);\n        });\n      },\n      put: function(e) {\n        const data = JSON.parse(e.data);\n        updateSettings(data);\n      },\n      patch: function(e) {\n        const data = JSON.parse(e.data);\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          postProcessSettingsUpdate(mods);\n        }\n      },\n      delete: function(e) {\n        const data = JSON.parse(e.data);\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          postProcessSettingsUpdate(mods);\n        }\n      },\n    });\n  }\n\n  function updateSettings(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key) && flags[key]) {\n        if (newFlags[key] && newFlags[key].value !== flags[key].value) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (newFlags.hasOwnProperty(key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = newFlags;\n    postProcessSettingsUpdate(changes);\n  }\n\n  function postProcessSettingsUpdate(changes) {\n    const keys = Object.keys(changes);\n\n    if (useLocalStorage) {\n      store.saveFlags(flags);\n    }\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n\n      if (!sendEventsOnlyForVariation) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n  }\n\n  function on(event, handler, context) {\n    if (event.substr(0, changeEvent.length) === changeEvent) {\n      subscribedToChangeEvents = true;\n      if (!stream.isConnected()) {\n        connectStream();\n      }\n      emitter.on.apply(emitter, [event, handler, context]);\n    } else {\n      emitter.on.apply(emitter, Array.prototype.slice.call(arguments));\n    }\n  }\n\n  function off(event) {\n    if (event === changeEvent) {\n      if ((subscribedToChangeEvents = true)) {\n        subscribedToChangeEvents = false;\n        stream.disconnect();\n      }\n    }\n    emitter.off.apply(emitter, Array.prototype.slice.call(arguments));\n  }\n\n  function handleMessage(event) {\n    if (event.origin !== baseUrl) {\n      return;\n    }\n    if (event.data.type === 'SYN') {\n      window.editorClientBaseUrl = baseUrl;\n      const editorTag = document.createElement('script');\n      editorTag.type = 'text/javascript';\n      editorTag.async = true;\n      editorTag.src = baseUrl + event.data.editorClientUrl;\n      const s = document.getElementsByTagName('script')[0];\n      s.parentNode.insertBefore(editorTag, s);\n    }\n  }\n\n  if (!env) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    });\n  }\n\n  if (!user) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    });\n  } else if (!user.key) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.invalidUser()));\n    });\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    utils.onNextTick(signalSuccessfulInit);\n  } else if (\n    typeof options.bootstrap === 'string' &&\n    options.bootstrap.toUpperCase() === 'LOCALSTORAGE' &&\n    !!localStorage\n  ) {\n    useLocalStorage = true;\n\n    flags = store.loadFlags();\n\n    if (flags === null) {\n      flags = {};\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n          signalFailedInit(initErr);\n        } else {\n          if (settings) {\n            flags = settings;\n            store.saveFlags(flags);\n          } else {\n            flags = {};\n          }\n          signalSuccessfulInit();\n        }\n      });\n    } else {\n      // We're reading the flags from local storage. Signal that we're ready,\n      // then update localStorage for the next page load. We won't signal changes or update\n      // the in-memory flags unless you subscribe for changes\n      utils.onNextTick(signalSuccessfulInit);\n\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n        }\n        if (settings) {\n          store.saveFlags(settings);\n        }\n      });\n    }\n  } else {\n    requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n      if (err) {\n        flags = {};\n        const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n        signalFailedInit(initErr);\n      } else {\n        flags = settings || {};\n        signalSuccessfulInit();\n      }\n    });\n  }\n\n  function refreshGoalTracker() {\n    if (goalTracker) {\n      goalTracker.dispose();\n    }\n    if (goals && goals.length) {\n      goalTracker = GoalTracker(goals, sendGoalEvent);\n    }\n  }\n\n  function watchLocation(interval, callback) {\n    let previousUrl = location.href;\n    let currentUrl;\n\n    function checkUrl() {\n      currentUrl = location.href;\n\n      if (currentUrl !== previousUrl) {\n        previousUrl = currentUrl;\n        callback();\n      }\n    }\n\n    function poll(fn, interval) {\n      fn();\n      setTimeout(() => {\n        poll(fn, interval);\n      }, interval);\n    }\n\n    poll(checkUrl, interval);\n\n    if (!!(window.history && history.pushState)) {\n      window.addEventListener('popstate', checkUrl);\n    } else {\n      window.addEventListener('hashchange', checkUrl);\n    }\n  }\n\n  if (fetchGoals) {\n    requestor.fetchGoals((err, g) => {\n      if (err) {\n        emitter.maybeReportError(\n          new errors.LDUnexpectedResponseError('Error fetching goals: ' + err.message ? err.message : err)\n        );\n      }\n      if (g && g.length > 0) {\n        goals = g;\n        goalTracker = GoalTracker(goals, sendGoalEvent);\n        watchLocation(locationWatcherInterval, refreshGoalTracker);\n      }\n      emitter.emit(goalsEvent);\n    });\n  }\n\n  function signalSuccessfulInit() {\n    emitter.emit(readyEvent);\n    emitter.emit(successEvent); // allows initPromise to distinguish between success and failure\n  }\n\n  function signalFailedInit(err) {\n    emitter.maybeReportError(err);\n    emitter.emit(failedEvent, err);\n    emitter.emit(readyEvent); // for backward compatibility, this event happens even on failure\n  }\n\n  function start() {\n    if (sendEvents) {\n      events.start();\n    }\n  }\n\n  if (document.readyState !== 'complete') {\n    window.addEventListener('load', start);\n  } else {\n    start();\n  }\n\n  window.addEventListener('beforeunload', () => {\n    if (sendEvents) {\n      events.stop();\n      events.flush(true);\n    }\n  });\n\n  window.addEventListener('message', handleMessage);\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = emitter.on(readyEvent, () => {\n      emitter.off(readyEvent, onReady);\n      resolve();\n    });\n  });\n\n  const goalsPromise = new Promise(resolve => {\n    const onGoals = emitter.on(goalsEvent, () => {\n      emitter.off(goalsEvent, onGoals);\n      resolve();\n    });\n  });\n\n  const initPromise = new Promise((resolve, reject) => {\n    const onSuccess = emitter.on(successEvent, () => {\n      emitter.off(successEvent, onSuccess);\n      resolve();\n    });\n    const onFailure = emitter.on(failedEvent, err => {\n      emitter.off(failedEvent, onFailure);\n      reject(err);\n    });\n  });\n\n  const client = {\n    waitForInitialization: () => initPromise,\n    waitUntilReady: () => readyPromise,\n    waitUntilGoalsReady: () => goalsPromise,\n    identify: identify,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    flush: flush,\n    allFlags: allFlags,\n  };\n\n  return client;\n}\n\nexport const version = VERSION;\n\nfunction deprecatedInitialize(env, user, options = {}) {\n  console && console.warn && console.warn(messages.deprecated('default export', 'named LDClient export'));\n  return initialize(env, user, options);\n}\n\nexport default { initialize: deprecatedInitialize, version };\n"],"names":["createCustomError","name","CustomError","message","code","captureStackTrace","Error","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","isHttpErrorRecoverable","status","object","exports","chars","InvalidCharacterError","btoa","input","block","charCode","str","String","idx","map","output","charAt","charCodeAt","atob","replace","length","bs","buffer","bc","fromCharCode","indexOf","s","Base64","unescape","encodeURIComponent","base64URLEncode","clone","obj","JSON","parse","stringify","onNextTick","cb","wrapPromiseCallback","promise","callback","ret","then","value","Promise","reject","error","undefined","transformValuesToVersionedValues","flags","key","hasOwnProperty","version","transformVersionedValuesToValues","flagsState","chunkUserEventsForUrl","maxLength","events","allEvents","slice","allChunks","remainingSpace","chunk","event","shift","unshift","push","getLDUserAgentString","addLDHeaders","xhr","setRequestHeader","extend","objects","reduce","acc","MAX_URL_LENGTH","EventSender","eventsUrl","environmentId","forceHasCors","imageCreator","sendLDHeaders","hasCors","postUrl","imageUrl","sender","loadUrlUsingImage","src","onDone","img","Image","addEventListener","sendChunk","usePost","sync","createImage","jsonBody","send","createRequest","canRetry","XMLHttpRequest","open","errors","dateStr","getResponseHeader","time","Date","serverTime","getResponseInfo","utils","resolve","sendEvents","finalSync","chunks","results","i","all","EventSummarizer","es","startDate","endDate","counters","summarizeEvent","kind","counterKey","variation","counterVal","count","default","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","clearSummary","docLink","localStorageUnavailable","unknownCustomEventKey","environmentNotFound","environmentNotSpecified","errorFetchingFlags","err","userNotSpecified","invalidUser","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","UserFilter","config","filter","allAttributesPrivate","all_attributes_private","privateAttributeNames","private_attribute_names","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","console","warn","messages","filterUser","user","userPrivateAttrs","filterAttrs","props","isAttributeAllowed","Object","keys","isPrivateAttr","result","filteredProps","removedAttrs","customResult","removedAttrNames","sort","privateAttrs","EventProcessor","options","emitter","processor","eventSender","summarizer","userFilter","inlineUsers","inlineUsersInEvents","queue","flushInterval","samplingInterval","lastKnownPastTime","disabled","flushTimer","reportArgumentError","maybeReportError","shouldSampleEvent","Math","floor","random","isNaN","isNan","enqueue","e","addFullEvent","addDebugEvent","trackEvents","debugEventsUntilDate","getTime","userKey","makeOutputEvent","debugEvent","flush","eventsToSend","summary","responseInfo","start","setTimeout","flushTick","stop","EventEmitter","on","handler","concat","off","emit","apply","Array","call","arguments","matchOperatorsRe","TypeError","doesUrlMatch","matcher","href","search","hash","canonicalUrl","regex","testUrl","RegExp","escapeStringRegexp","url","substring","pattern","test","findGoalsForClick","clickGoals","matches","target","goal","selector","elements","document","querySelectorAll","j","parentNode","GoalTracker","goals","onEvent","tracker","listenerFn","urls","location","dispose","removeEventListener","Store","environment","ident","store","getFlagsKey","getUser","loadFlags","dataStr","data","localStorage","getItem","ex","clearFlags","schema","$schema","saveFlags","setItem","removeItem","Stream","baseUrl","stream","evalUrlPrefix","useReport","withReasons","evaluationReasons","streamReconnectDelay","reconnectTimeoutReference","handlers","reconnect","tryConnect","delay","openConnection","query","EventSource","window","onerror","closeConnection","close","connect","newUser","newHandlers","disconnect","isConnected","readyState","OPEN","CONNECTING","json","fetchJSON","endpoint","body","lastIndexOf","responseText","getResponseError","statusText","Requestor","flagSettingsRequest","lastFlagSettingsCallback","requestor","join","currentCallback","prevCallback","wrappedCallback","abort","sanitizeUser","u","sane","toString","Identity","initialUser","onChange","setUser","readyEvent","successEvent","failedEvent","changeEvent","goalsEvent","locationWatcherInterval","initialize","env","streamUrl","optionWithDefault","allowFrequentDuplicateEvents","sendEventsOnlyForVariation","fetchGoals","eventProcessor","seenRequests","_typeof","bootstrap","metadata","forEach","readFlagsFromBootstrap","goalTracker","useLocalStorage","subscribedToChangeEvents","firstEvent","defaultVal","shouldEnqueueEvent","navigator","doNotTrack","msDoNotTrack","enqueueEvent","sendFlagEvent","detail","defaultValue","now","cacheKey","cached","variationIndex","reason","flagVersion","sendGoalEvent","variationDetailInternal","sendEvent","deleted","getFlagDetail","errorKind","connectStream","fetchFlagSettings","settings","oldFlag","mods","newFlag","newDetail","previous","current","updateSettings","newFlags","changes","postProcessSettingsUpdate","changeEventParams","refreshGoalTracker","signalSuccessfulInit","signalFailedInit","toUpperCase","g","interval","previousUrl","currentUrl","checkUrl","poll","fn","history","pushState","origin","type","editorClientBaseUrl","editorTag","createElement","async","editorClientUrl","getElementsByTagName","insertBefore","readyPromise","onReady","goalsPromise","onGoals","initPromise","onSuccess","onFailure","customEventExists","substr","deprecatedInitialize"],"mappings":"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"}