{"version":3,"file":"ldclient.min.js","sources":["../src/errors.js","../node_modules/Base64/base64.js","../src/utils.js","../src/EventSender.js","../src/messages.js","../src/UserFilter.js","../src/EventProcessor.js","../src/EventSummarizer.js","../src/EventEmitter.js","../node_modules/escape-string-regexp/index.js","../src/GoalTracker.js","../src/Requestor.js","../src/Identity.js","../src/index.js","../src/Stream.js","../src/Store.js"],"sourcesContent":["function createCustomError(name) {\n  function CustomError(message, code) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    this.message = message;\n    this.code = code;\n  }\n\n  CustomError.prototype = new Error();\n  CustomError.prototype.name = name;\n  CustomError.prototype.constructor = CustomError;\n\n  return CustomError;\n}\n\nexport const LDUnexpectedResponseError = createCustomError('LaunchDarklyUnexpectedResponseError');\nexport const LDInvalidEnvironmentIdError = createCustomError('LaunchDarklyInvalidEnvironmentIdError');\nexport const LDInvalidUserError = createCustomError('LaunchDarklyInvalidUserError');\nexport const LDInvalidEventKeyError = createCustomError('LaunchDarklyInvalidEventKeyError');\nexport const LDInvalidArgumentError = createCustomError('LaunchDarklyInvalidArgumentError');\nexport const LDFlagFetchError = createCustomError('LaunchDarklyFlagFetchError');\n\nexport function isHttpErrorRecoverable(status) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}\n",";(function () {\n\n  var object =\n    typeof exports != 'undefined' ? exports :\n    typeof self != 'undefined' ? self : // #8: web workers\n    $.global; // #31: ExtendScript\n\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    var str = String(input);\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next str index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      str.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = str.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    var str = String(input).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=\n    if (str.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n","import Base64 from 'Base64';\n\n// See http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\nexport function btoa(s) {\n  return Base64.btoa(unescape(encodeURIComponent(s)));\n}\n\nexport function base64URLEncode(s) {\n  return (\n    btoa(s)\n      // eslint-disable-next-line\n      .replace(/=/g, '')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n  );\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// Events emitted in LDClient's initialize method will happen before the consumer\n// can register a listener, so defer them to next tick.\nexport function onNextTick(cb) {\n  setTimeout(cb, 0);\n}\n\n/**\n * Wrap a promise to invoke an optional callback upon resolution or rejection.\n *\n * This function assumes the callback follows the Node.js callback type: (err, value) => void\n *\n * If a callback is provided:\n *   - if the promise is resolved, invoke the callback with (null, value)\n *   - if the promise is rejected, invoke the callback with (error, null)\n *\n * @param {Promise<any>} promise\n * @param {Function} callback\n * @returns Promise<any> | undefined\n */\nexport function wrapPromiseCallback(promise, callback) {\n  const ret = promise.then(\n    value => {\n      if (callback) {\n        setTimeout(() => {\n          callback(null, value);\n        }, 0);\n      }\n      return value;\n    },\n    error => {\n      if (callback) {\n        setTimeout(() => {\n          callback(error, null);\n        }, 0);\n      } else {\n        return Promise.reject(error);\n      }\n    }\n  );\n\n  return !callback ? ret : undefined;\n}\n\n/**\n * Takes a map of flag keys to values, and returns the more verbose structure used by the\n * client stream.\n */\nexport function transformValuesToVersionedValues(flags) {\n  const ret = {};\n  for (const key in flags) {\n    if (flags.hasOwnProperty(key)) {\n      ret[key] = { value: flags[key], version: 0 };\n    }\n  }\n  return ret;\n}\n\n/**\n * Converts the internal flag state map to a simple map of flag keys to values.\n */\nexport function transformVersionedValuesToValues(flagsState) {\n  const ret = {};\n  for (const key in flagsState) {\n    if (flagsState.hasOwnProperty(key)) {\n      ret[key] = flagsState[key].value;\n    }\n  }\n  return ret;\n}\n\n/**\n * Returns an array of event groups each of which can be safely URL-encoded\n * without hitting the safe maximum URL length of certain browsers.\n *\n * @param {number} maxLength maximum URL length targeted\n * @param {Array[Object}]} events queue of events to divide\n * @returns Array[Array[Object]]\n */\nexport function chunkUserEventsForUrl(maxLength, events) {\n  const allEvents = events.slice(0);\n  const allChunks = [];\n  let remainingSpace = maxLength;\n  let chunk;\n\n  while (allEvents.length > 0) {\n    chunk = [];\n\n    while (remainingSpace > 0) {\n      const event = allEvents.shift();\n      if (!event) {\n        break;\n      }\n      remainingSpace = remainingSpace - base64URLEncode(JSON.stringify(event)).length;\n      // If we are over the max size, put this one back on the queue\n      // to try in the next round, unless this event alone is larger\n      // than the limit, in which case, screw it, and try it anyway.\n      if (remainingSpace < 0 && chunk.length > 0) {\n        allEvents.unshift(event);\n      } else {\n        chunk.push(event);\n      }\n    }\n\n    remainingSpace = maxLength;\n    allChunks.push(chunk);\n  }\n\n  return allChunks;\n}\n\nexport function getLDUserAgentString() {\n  return 'JSClient/' + VERSION;\n}\n\nexport function addLDHeaders(xhr) {\n  xhr.setRequestHeader('X-LaunchDarkly-User-Agent', getLDUserAgentString());\n}\n\nexport function extend(...objects) {\n  return objects.reduce((acc, obj) => ({ ...acc, ...obj }), {});\n}\n","import * as errors from './errors';\nimport * as utils from './utils';\n\nconst MAX_URL_LENGTH = 2000;\n\nexport default function EventSender(eventsUrl, environmentId, forceHasCors, imageCreator, sendLDHeaders = true) {\n  let hasCors;\n  const postUrl = eventsUrl + '/events/bulk/' + environmentId;\n  const imageUrl = eventsUrl + '/a/' + environmentId + '.gif';\n  const sender = {};\n\n  function loadUrlUsingImage(src, onDone) {\n    const img = new Image();\n    if (onDone) {\n      img.addEventListener('load', onDone);\n    }\n    img.src = src;\n  }\n\n  function getResponseInfo(xhr) {\n    const ret = { status: xhr.status };\n    const dateStr = xhr.getResponseHeader('Date');\n    if (dateStr) {\n      const time = Date.parse(dateStr);\n      if (time) {\n        ret.serverTime = time;\n      }\n    }\n    return ret;\n  }\n\n  function sendChunk(events, usePost, sync) {\n    const createImage = imageCreator || loadUrlUsingImage;\n    const jsonBody = JSON.stringify(events);\n    const send = onDone => {\n      function createRequest(canRetry) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', postUrl, !sync);\n        if (sendLDHeaders) {\n          utils.addLDHeaders(xhr);\n        }\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.setRequestHeader('X-LaunchDarkly-Event-Schema', '3');\n        if (!sync) {\n          xhr.addEventListener('load', () => {\n            if (xhr.status >= 400 && errors.isHttpErrorRecoverable(xhr.status) && canRetry) {\n              createRequest(false).send(jsonBody);\n            } else {\n              onDone(getResponseInfo(xhr));\n            }\n          });\n          if (canRetry) {\n            xhr.addEventListener('error', () => {\n              createRequest(false).send(jsonBody);\n            });\n          }\n        }\n        return xhr;\n      }\n      if (usePost) {\n        createRequest(true).send(jsonBody);\n      } else {\n        const src = imageUrl + '?d=' + utils.base64URLEncode(jsonBody);\n        createImage(src, sync ? null : onDone);\n      }\n    };\n\n    if (sync) {\n      send();\n    } else {\n      return new Promise(resolve => {\n        send(resolve);\n      });\n    }\n  }\n\n  sender.sendEvents = function(events, sync) {\n    // Detect browser support for CORS (can be overridden by tests)\n    if (hasCors === undefined) {\n      if (forceHasCors === undefined) {\n        hasCors = 'withCredentials' in new XMLHttpRequest();\n      } else {\n        hasCors = forceHasCors;\n      }\n    }\n\n    const finalSync = sync === undefined ? false : sync;\n    let chunks;\n    if (hasCors) {\n      // no need to break up events into chunks if we can send a POST\n      chunks = [events];\n    } else {\n      chunks = utils.chunkUserEventsForUrl(MAX_URL_LENGTH - eventsUrl.length, events);\n    }\n    const results = [];\n    for (let i = 0; i < chunks.length; i++) {\n      results.push(sendChunk(chunks[i], hasCors, finalSync));\n    }\n    return sync ? Promise.resolve() : Promise.all(results);\n  };\n\n  return sender;\n}\n","const docLink =\n  ' Please see https://docs.launchdarkly.com/docs/js-sdk-reference#section-initializing-the-client for instructions on SDK initialization.';\n\nexport const clientNotReady = function() {\n  return 'LaunchDarkly client is not ready';\n};\n\nexport const invalidKey = function() {\n  return 'Event key must be a string';\n};\n\nexport const localStorageUnavailable = function() {\n  return 'localStorage is unavailable';\n};\n\nexport const unknownCustomEventKey = function(key) {\n  return 'Custom event \"' + key + '\" does not exist';\n};\n\nexport const environmentNotFound = function() {\n  return 'environment not found.' + docLink;\n};\n\nexport const environmentNotSpecified = function() {\n  return 'No environment specified.' + docLink;\n};\n\nexport const errorFetchingFlags = function(err) {\n  return 'Error fetching flag settings: ' + (err.message || err);\n};\n\nexport const userNotSpecified = function() {\n  return 'No user specified.' + docLink;\n};\n\nexport const invalidUser = function() {\n  return 'Invalid user specified.' + docLink;\n};\n\nexport const bootstrapOldFormat = function() {\n  return (\n    'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. ' +\n    'Events may not be sent correctly.' +\n    docLink\n  );\n};\n\nexport const bootstrapInvalid = function() {\n  return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';\n};\n\nexport const deprecated = function(oldName, newName) {\n  return '[LaunchDarkly] \"' + oldName + '\" is deprecated, please use \"' + newName + '\"';\n};\n\nexport const httpErrorMessage = function(status, context, retryMessage) {\n  return (\n    'Received error ' +\n    status +\n    (status === 401 ? ' (invalid SDK key)' : '') +\n    ' for ' +\n    context +\n    ' - ' +\n    (errors.isHttpErrorRecoverable(status) ? retryMessage : 'giving up permanently')\n  );\n};\n","import * as messages from './messages';\nimport * as utils from './utils';\n\n/**\n * The UserFilter object transforms user objects into objects suitable to be sent as JSON to\n * the server, hiding any private user attributes.\n *\n * @param {Object} the LaunchDarkly client configuration object\n **/\nexport default function UserFilter(config) {\n  const filter = {};\n  const allAttributesPrivate =\n    config.allAttributesPrivate !== undefined ? config.allAttributesPrivate : config.all_attributes_private;\n  const privateAttributeNames =\n    (config.privateAttributeNames !== undefined ? config.privateAttributeNames : config.private_attribute_names) || [];\n  const ignoreAttrs = { key: true, custom: true, anonymous: true };\n  const allowedTopLevelAttrs = {\n    key: true,\n    secondary: true,\n    ip: true,\n    country: true,\n    email: true,\n    firstName: true,\n    lastName: true,\n    avatar: true,\n    name: true,\n    anonymous: true,\n    custom: true,\n  };\n\n  if (config.all_attributes_private !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('all_attributes_private', 'allAttributesPrivate'));\n  }\n  if (config.private_attribute_names !== undefined) {\n    console && console.warn && console.warn(messages.deprecated('private_attribute_names', 'privateAttributeNames'));\n  }\n\n  filter.filterUser = function(user) {\n    if (!user) {\n      return null;\n    }\n    const userPrivateAttrs = user.privateAttributeNames || [];\n\n    const isPrivateAttr = function(name) {\n      return (\n        !ignoreAttrs[name] &&\n        (allAttributesPrivate || userPrivateAttrs.indexOf(name) !== -1 || privateAttributeNames.indexOf(name) !== -1)\n      );\n    };\n    const filterAttrs = function(props, isAttributeAllowed) {\n      return Object.keys(props).reduce(\n        (acc, name) => {\n          const ret = acc;\n          if (isAttributeAllowed(name)) {\n            if (isPrivateAttr(name)) {\n              // add to hidden list\n              ret[1][name] = true;\n            } else {\n              ret[0][name] = props[name];\n            }\n          }\n          return ret;\n        },\n        [{}, {}]\n      );\n    };\n    const result = filterAttrs(user, key => allowedTopLevelAttrs[key]);\n    const filteredProps = result[0];\n    let removedAttrs = result[1];\n    if (user.custom) {\n      const customResult = filterAttrs(user.custom, () => true);\n      filteredProps.custom = customResult[0];\n      removedAttrs = utils.extend({}, removedAttrs, customResult[1]);\n    }\n    const removedAttrNames = Object.keys(removedAttrs);\n    if (removedAttrNames.length) {\n      removedAttrNames.sort();\n      filteredProps.privateAttrs = removedAttrNames;\n    }\n    return filteredProps;\n  };\n  return filter;\n}\n","import EventSender from './EventSender';\nimport EventSummarizer from './EventSummarizer';\nimport UserFilter from './UserFilter';\nimport * as errors from './errors';\nimport * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function EventProcessor(\n  eventsUrl,\n  environmentId,\n  options = {},\n  emitter = null,\n  sender = null,\n  sendLDHeaders\n) {\n  const processor = {};\n  const eventSender = sender || EventSender(eventsUrl, environmentId, sendLDHeaders);\n  const summarizer = EventSummarizer();\n  const userFilter = UserFilter(options);\n  const inlineUsers = !!options.inlineUsersInEvents;\n  let queue = [];\n  let flushInterval;\n  let samplingInterval;\n  let lastKnownPastTime = 0;\n  let disabled = false;\n  let flushTimer;\n\n  function reportArgumentError(message) {\n    utils.onNextTick(() => {\n      emitter && emitter.maybeReportError(new errors.LDInvalidArgumentError(message));\n    });\n  }\n\n  if (options.samplingInterval !== undefined && (isNaN(options.samplingInterval) || options.samplingInterval < 0)) {\n    samplingInterval = 0;\n    reportArgumentError('Invalid sampling interval configured. Sampling interval must be an integer >= 0.');\n  } else {\n    samplingInterval = options.samplingInterval || 0;\n  }\n\n  if (options.flushInterval !== undefined && (isNan(options.flushInterval) || options.flushInterval < 2000)) {\n    flushInterval = 2000;\n    reportArgumentError('Invalid flush interval configured. Must be an integer >= 2000 (milliseconds).');\n  } else {\n    flushInterval = options.flushInterval || 2000;\n  }\n\n  function shouldSampleEvent() {\n    return samplingInterval === 0 || Math.floor(Math.random() * samplingInterval) === 0;\n  }\n\n  function shouldDebugEvent(e) {\n    if (e.debugEventsUntilDate) {\n      // The \"last known past time\" comes from the last HTTP response we got from the server.\n      // In case the client's time is set wrong, at least we know that any expiration date\n      // earlier than that point is definitely in the past.  If there's any discrepancy, we\n      // want to err on the side of cutting off event debugging sooner.\n      return e.debugEventsUntilDate > lastKnownPastTime && e.debugEventsUntilDate > new Date().getTime();\n    }\n    return false;\n  }\n\n  // Transform an event from its internal format to the format we use when sending a payload.\n  function makeOutputEvent(e) {\n    const ret = utils.extend({}, e);\n    if (inlineUsers || e.kind === 'identify') {\n      // identify events always have an inline user\n      ret.user = userFilter.filterUser(e.user);\n    } else {\n      ret.userKey = e.user.key;\n      delete ret['user'];\n    }\n    if (e.kind === 'feature') {\n      delete ret['trackEvents'];\n      delete ret['debugEventsUntilDate'];\n    }\n    return ret;\n  }\n\n  processor.enqueue = function(event) {\n    if (disabled) {\n      return;\n    }\n    let addFullEvent = false;\n    let addDebugEvent = false;\n\n    // Add event to the summary counters if appropriate\n    summarizer.summarizeEvent(event);\n\n    // Decide whether to add the event to the payload. Feature events may be added twice, once for\n    // the event (if tracked) and once for debugging.\n    if (event.kind === 'feature') {\n      if (shouldSampleEvent()) {\n        addFullEvent = !!event.trackEvents;\n        addDebugEvent = shouldDebugEvent(event);\n      }\n    } else {\n      addFullEvent = shouldSampleEvent();\n    }\n\n    if (addFullEvent) {\n      queue.push(makeOutputEvent(event));\n    }\n    if (addDebugEvent) {\n      const debugEvent = utils.extend({}, event, { kind: 'debug' });\n      delete debugEvent['trackEvents'];\n      delete debugEvent['debugEventsUntilDate'];\n      delete debugEvent['variation'];\n      queue.push(debugEvent);\n    }\n  };\n\n  processor.flush = function(sync) {\n    if (disabled) {\n      return Promise.resolve();\n    }\n    const eventsToSend = queue;\n    const summary = summarizer.getSummary();\n    summarizer.clearSummary();\n    if (summary) {\n      summary.kind = 'summary';\n      eventsToSend.push(summary);\n    }\n    if (eventsToSend.length === 0) {\n      return Promise.resolve();\n    }\n    queue = [];\n    return eventSender.sendEvents(eventsToSend, sync).then(responseInfo => {\n      if (responseInfo) {\n        if (responseInfo.serverTime) {\n          lastKnownPastTime = responseInfo.serverTime;\n        }\n        if (!errors.isHttpErrorRecoverable(responseInfo.status)) {\n          disabled = true;\n        }\n        if (responseInfo.status >= 400) {\n          utils.onNextTick(() => {\n            emitter.maybeReportError(\n              new errors.LDUnexpectedResponseError(\n                messages.httpErrorMessage(responseInfo.status, 'event posting', 'some events were dropped')\n              )\n            );\n          });\n        }\n      }\n    });\n  };\n\n  processor.start = function() {\n    const flushTick = () => {\n      processor.flush();\n      flushTimer = setTimeout(flushTick, flushInterval);\n    };\n    flushTimer = setTimeout(flushTick, flushInterval);\n  };\n\n  processor.stop = function() {\n    clearTimeout(flushTimer);\n  };\n\n  return processor;\n}\n","export default function EventSummarizer() {\n  const es = {};\n\n  let startDate = 0,\n    endDate = 0,\n    counters = {};\n\n  es.summarizeEvent = function(event) {\n    if (event.kind === 'feature') {\n      const counterKey =\n        event.key +\n        ':' +\n        (event.variation !== null && event.variation !== undefined ? event.variation : '') +\n        ':' +\n        (event.version !== null && event.version !== undefined ? event.version : '');\n      const counterVal = counters[counterKey];\n      if (counterVal) {\n        counterVal.count = counterVal.count + 1;\n      } else {\n        counters[counterKey] = {\n          count: 1,\n          key: event.key,\n          variation: event.variation,\n          version: event.version,\n          value: event.value,\n          default: event.default,\n        };\n      }\n      if (startDate === 0 || event.creationDate < startDate) {\n        startDate = event.creationDate;\n      }\n      if (event.creationDate > endDate) {\n        endDate = event.creationDate;\n      }\n    }\n  };\n\n  es.getSummary = function() {\n    const flagsOut = {};\n    let empty = true;\n    for (const i in counters) {\n      const c = counters[i];\n      let flag = flagsOut[c.key];\n      if (!flag) {\n        flag = {\n          default: c.default,\n          counters: [],\n        };\n        flagsOut[c.key] = flag;\n      }\n      const counterOut = {\n        value: c.value,\n        count: c.count,\n      };\n      if (c.variation !== undefined && c.variation !== null) {\n        counterOut.variation = c.variation;\n      }\n      if (c.version) {\n        counterOut.version = c.version;\n      } else {\n        counterOut.unknown = true;\n      }\n      flag.counters.push(counterOut);\n      empty = false;\n    }\n    return empty\n      ? null\n      : {\n          startDate,\n          endDate,\n          features: flagsOut,\n        };\n  };\n\n  es.clearSummary = function() {\n    startDate = 0;\n    endDate = 0;\n    counters = {};\n  };\n\n  return es;\n}\n","export default function EventEmitter() {\n  const emitter = {};\n  const events = {};\n\n  const listeningTo = event => !!events[event];\n\n  emitter.on = function(event, handler, context) {\n    events[event] = events[event] || [];\n    events[event] = events[event].concat({\n      handler: handler,\n      context: context,\n    });\n  };\n\n  emitter.off = function(event, handler, context) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      if (events[event][i].handler === handler && events[event][i].context === context) {\n        events[event] = events[event].slice(0, i).concat(events[event].slice(i + 1));\n      }\n    }\n  };\n\n  emitter.emit = function(event) {\n    if (!events[event]) {\n      return;\n    }\n    for (let i = 0; i < events[event].length; i++) {\n      events[event][i].handler.apply(events[event][i].context, Array.prototype.slice.call(arguments, 1));\n    }\n  };\n\n  emitter.maybeReportError = function(error) {\n    if (!error) {\n      return;\n    }\n    if (listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      console.error(error.message);\n    }\n  };\n  return emitter;\n}\n","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n","import escapeStringRegexp from 'escape-string-regexp';\n\nfunction doesUrlMatch(matcher, href, search, hash) {\n  const canonicalUrl = href.replace(search, '').replace(hash, '');\n  let regex;\n  let testUrl;\n\n  switch (matcher.kind) {\n    case 'exact':\n      testUrl = href;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'canonical':\n      testUrl = canonicalUrl;\n      regex = new RegExp('^' + escapeStringRegexp(matcher.url) + '/?$');\n      break;\n    case 'substring':\n      testUrl = canonicalUrl;\n      regex = new RegExp('.*' + escapeStringRegexp(matcher.substring) + '.*$');\n      break;\n    case 'regex':\n      testUrl = canonicalUrl;\n      regex = new RegExp(matcher.pattern);\n      break;\n    default:\n      return false;\n  }\n  return regex.test(testUrl);\n}\n\nfunction findGoalsForClick(event, clickGoals) {\n  const matches = [];\n\n  for (let i = 0; i < clickGoals.length; i++) {\n    let target = event.target;\n    const goal = clickGoals[i];\n    const selector = goal.selector;\n    const elements = document.querySelectorAll(selector);\n    while (target && elements.length > 0) {\n      for (let j = 0; j < elements.length; j++) {\n        if (target === elements[j]) {\n          matches.push(goal);\n        }\n      }\n      target = target.parentNode;\n    }\n  }\n\n  return matches;\n}\n\nexport default function GoalTracker(goals, onEvent) {\n  const tracker = {};\n  let listenerFn = null;\n\n  const clickGoals = [];\n\n  for (let i = 0; i < goals.length; i++) {\n    const goal = goals[i];\n    const urls = goal.urls || [];\n\n    for (let j = 0; j < urls.length; j++) {\n      if (doesUrlMatch(urls[j], location.href, location.search, location.hash)) {\n        if (goal.kind === 'pageview') {\n          onEvent('pageview', goal);\n        } else {\n          clickGoals.push(goal);\n          onEvent('click_pageview', goal);\n        }\n        break;\n      }\n    }\n  }\n\n  if (clickGoals.length > 0) {\n    listenerFn = function(event) {\n      const goals = findGoalsForClick(event, clickGoals);\n      for (let i = 0; i < goals.length; i++) {\n        onEvent('click', goals[i]);\n      }\n    };\n\n    document.addEventListener('click', listenerFn);\n  }\n\n  tracker.dispose = function() {\n    document.removeEventListener('click', listenerFn);\n  };\n\n  return tracker;\n}\n","import * as utils from './utils';\nimport * as errors from './errors';\nimport * as messages from './messages';\n\nconst json = 'application/json';\n\nfunction fetchJSON(endpoint, body, callback, sendLDHeaders) {\n  const xhr = new XMLHttpRequest();\n  let data = undefined;\n\n  xhr.addEventListener('load', () => {\n    if (\n      xhr.status === 200 &&\n      xhr.getResponseHeader('Content-type') &&\n      xhr.getResponseHeader('Content-Type').lastIndexOf(json) === 0\n    ) {\n      callback(null, JSON.parse(xhr.responseText));\n    } else {\n      callback(getResponseError(xhr));\n    }\n  });\n\n  xhr.addEventListener('error', () => {\n    callback(getResponseError(xhr));\n  });\n\n  if (body) {\n    xhr.open('REPORT', endpoint);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    data = JSON.stringify(body);\n  } else {\n    xhr.open('GET', endpoint);\n  }\n\n  if (sendLDHeaders) {\n    utils.addLDHeaders(xhr);\n  }\n\n  xhr.send(data);\n\n  return xhr;\n}\n\nfunction getResponseError(xhr) {\n  if (xhr.status === 404) {\n    return new errors.LDInvalidEnvironmentIdError(messages.environmentNotFound());\n  } else {\n    return xhr.statusText;\n  }\n}\n\nexport default function Requestor(baseUrl, environment, useReport, withReasons, sendLDHeaders) {\n  let flagSettingsRequest;\n  let lastFlagSettingsCallback;\n\n  const requestor = {};\n\n  requestor.fetchFlagSettings = function(user, hash, callback) {\n    let data;\n    let endpoint;\n    let query = '';\n    let body;\n    let cb;\n\n    if (useReport) {\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/user'].join('');\n      body = user;\n    } else {\n      data = utils.base64URLEncode(JSON.stringify(user));\n      endpoint = [baseUrl, '/sdk/evalx/', environment, '/users/', data].join('');\n    }\n    if (hash) {\n      query = 'h=' + hash;\n    }\n    if (withReasons) {\n      query = query + (query ? '&' : '') + 'withReasons=true';\n    }\n    endpoint = endpoint + (query ? '?' : '') + query;\n\n    const wrappedCallback = (function(currentCallback) {\n      return function(error, result) {\n        currentCallback(error, result);\n        flagSettingsRequest = null;\n        lastFlagSettingsCallback = null;\n      };\n    })(callback);\n\n    if (flagSettingsRequest) {\n      flagSettingsRequest.abort();\n      cb = (function(prevCallback) {\n        return function() {\n          prevCallback && prevCallback.apply(null, arguments);\n          wrappedCallback.apply(null, arguments);\n        };\n      })(lastFlagSettingsCallback);\n    } else {\n      cb = wrappedCallback;\n    }\n\n    lastFlagSettingsCallback = cb;\n    flagSettingsRequest = fetchJSON(endpoint, body, cb, sendLDHeaders);\n  };\n\n  requestor.fetchGoals = function(callback) {\n    const endpoint = [baseUrl, '/sdk/goals/', environment].join('');\n    fetchJSON(endpoint, null, callback, sendLDHeaders);\n  };\n\n  return requestor;\n}\n","import * as utils from './utils';\n\nfunction sanitizeUser(u) {\n  const sane = utils.clone(u);\n  if (sane.key) {\n    sane.key = sane.key.toString();\n  }\n  return sane;\n}\n\nexport default function Identity(initialUser, onChange) {\n  const ident = {};\n  let user;\n\n  ident.setUser = function(u) {\n    user = sanitizeUser(u);\n    onChange(utils.clone(user));\n  };\n\n  ident.getUser = function() {\n    return user ? utils.clone(user) : null;\n  };\n\n  if (initialUser) {\n    ident.setUser(initialUser);\n  }\n\n  return ident;\n}\n","import EventProcessor from './EventProcessor';\nimport EventEmitter from './EventEmitter';\nimport GoalTracker from './GoalTracker';\nimport Store from './Store';\nimport Stream from './Stream';\nimport Requestor from './Requestor';\nimport Identity from './Identity';\nimport * as utils from './utils';\nimport * as messages from './messages';\nimport * as errors from './errors';\n\nconst readyEvent = 'ready';\nconst successEvent = 'initialized';\nconst failedEvent = 'failed';\nconst changeEvent = 'change';\nconst goalsEvent = 'goalsReady';\nconst locationWatcherInterval = 300;\n\nexport function initialize(env, user, options = {}) {\n  const baseUrl = options.baseUrl || 'https://app.launchdarkly.com';\n  const eventsUrl = options.eventsUrl || 'https://events.launchdarkly.com';\n  const streamUrl = options.streamUrl || 'https://clientstream.launchdarkly.com';\n  const hash = options.hash;\n  const sendEvents = optionWithDefault('sendEvents', true);\n  const sendLDHeaders = optionWithDefault('sendLDHeaders', true);\n  const allowFrequentDuplicateEvents = !!options.allowFrequentDuplicateEvents;\n  const sendEventsOnlyForVariation = !!options.sendEventsOnlyForVariation;\n  const fetchGoals = typeof options.fetchGoals === 'undefined' ? true : options.fetchGoals;\n  const environment = env;\n  const emitter = EventEmitter();\n  const stream = Stream(streamUrl, environment, hash, options);\n  const events =\n    options.eventProcessor || EventProcessor(eventsUrl, environment, options, emitter, null, sendLDHeaders);\n  const requestor = Requestor(baseUrl, environment, options.useReport, options.evaluationReasons, sendLDHeaders);\n  const seenRequests = {};\n  let flags = typeof options.bootstrap === 'object' ? readFlagsFromBootstrap(options.bootstrap) : {};\n  let goalTracker;\n  let useLocalStorage;\n  let goals;\n  let subscribedToChangeEvents;\n  let firstEvent = true;\n\n  function optionWithDefault(name, defaultVal) {\n    return typeof options[name] === 'undefined' ? defaultVal : options[name];\n  }\n\n  function readFlagsFromBootstrap(data) {\n    // If the bootstrap data came from an older server-side SDK, we'll have just a map of keys to values.\n    // Newer SDKs that have an allFlagsState method will provide an extra \"$flagsState\" key that contains\n    // the rest of the metadata we want. We do it this way for backward compatibility with older JS SDKs.\n    const keys = Object.keys(data);\n    const metadataKey = '$flagsState';\n    const validKey = '$valid';\n    const metadata = data[metadataKey];\n    if (!metadata && keys.length) {\n      console.warn(messages.bootstrapOldFormat());\n    }\n    if (data[validKey] === false) {\n      console.warn(messages.bootstrapInvalid());\n    }\n    const ret = {};\n    keys.forEach(key => {\n      if (key !== metadataKey && key !== validKey) {\n        let flag = { value: data[key] };\n        if (metadata && metadata[key]) {\n          flag = utils.extend(flag, metadata[key]);\n        } else {\n          flag.version = 0;\n        }\n        ret[key] = flag;\n      }\n    });\n    return ret;\n  }\n\n  function shouldEnqueueEvent() {\n    return sendEvents && !doNotTrack();\n  }\n\n  function enqueueEvent(event) {\n    if (!event.user) {\n      if (firstEvent) {\n        if (console && console.warn) {\n          console.warn(\n            'Be sure to call `identify` in the LaunchDarkly client: http://docs.launchdarkly.com/docs/running-an-ab-test#include-the-client-side-snippet'\n          );\n        }\n        firstEvent = false;\n      }\n      return;\n    }\n    firstEvent = false;\n    if (shouldEnqueueEvent()) {\n      events.enqueue(event);\n    }\n  }\n\n  function sendIdentifyEvent(user) {\n    if (user) {\n      enqueueEvent({\n        kind: 'identify',\n        key: user.key,\n        user: user,\n        creationDate: new Date().getTime(),\n      });\n    }\n  }\n\n  const ident = Identity(user, sendIdentifyEvent);\n  const store = Store(environment, hash, ident);\n\n  function sendFlagEvent(key, detail, defaultValue) {\n    const user = ident.getUser();\n    const now = new Date();\n    const value = detail ? detail.value : null;\n    if (!allowFrequentDuplicateEvents) {\n      const cacheKey = JSON.stringify(value) + (user && user.key ? user.key : '') + key; // see below\n      const cached = seenRequests[cacheKey];\n      // cache TTL is five minutes\n      if (cached && now - cached < 300000) {\n        return;\n      }\n      seenRequests[cacheKey] = now;\n    }\n\n    const event = {\n      kind: 'feature',\n      key: key,\n      user: user,\n      value: value,\n      variation: detail ? detail.variationIndex : null,\n      default: defaultValue,\n      creationDate: now.getTime(),\n      reason: detail ? detail.reason : null,\n    };\n    const flag = flags[key];\n    if (flag) {\n      event.version = flag.flagVersion ? flag.flagVersion : flag.version;\n      event.trackEvents = flag.trackEvents;\n      event.debugEventsUntilDate = flag.debugEventsUntilDate;\n    }\n\n    enqueueEvent(event);\n  }\n\n  function sendGoalEvent(kind, goal) {\n    const event = {\n      kind: kind,\n      key: goal.key,\n      data: null,\n      url: window.location.href,\n      user: ident.getUser(),\n      creationDate: new Date().getTime(),\n    };\n\n    if (kind === 'click') {\n      event.selector = goal.selector;\n    }\n\n    return enqueueEvent(event);\n  }\n\n  function identify(user, hash, onDone) {\n    if (useLocalStorage) {\n      store.clearFlags();\n    }\n    return utils.wrapPromiseCallback(\n      new Promise((resolve, reject) => {\n        if (!user || user.key === null || user.key === undefined) {\n          const err = new errors.LDInvalidUserError(user ? messages.invalidUser() : messages.userNotSpecified());\n          emitter.maybeReportError(err);\n          reject(err);\n        } else {\n          ident.setUser(user);\n          requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n            if (err) {\n              emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n              return reject(err);\n            }\n            if (settings) {\n              updateSettings(settings);\n            }\n            resolve(utils.transformVersionedValuesToValues(settings));\n            if (subscribedToChangeEvents) {\n              connectStream();\n            }\n          });\n        }\n      }),\n      onDone\n    );\n  }\n\n  function flush(onDone) {\n    return utils.wrapPromiseCallback(\n      new Promise(resolve => (sendEvents ? resolve(events.flush()) : resolve()), onDone)\n    );\n  }\n\n  function variation(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true).value;\n  }\n\n  function variationDetail(key, defaultValue) {\n    return variationDetailInternal(key, defaultValue, true);\n  }\n\n  function variationDetailInternal(key, defaultValue, sendEvent) {\n    let detail;\n\n    if (flags && flags.hasOwnProperty(key) && flags[key] && !flags[key].deleted) {\n      const flag = flags[key];\n      detail = getFlagDetail(flag);\n      if (flag.value === null || flag.value === undefined) {\n        detail.value = defaultValue;\n      }\n    } else {\n      detail = { value: defaultValue, variationIndex: null, reason: { kind: 'ERROR', errorKind: 'FLAG_NOT_FOUND' } };\n    }\n\n    if (sendEvent) {\n      sendFlagEvent(key, detail, defaultValue);\n    }\n\n    return detail;\n  }\n\n  function getFlagDetail(flag) {\n    return {\n      value: flag.value,\n      variationIndex: flag.variation === undefined ? null : flag.variation,\n      reason: flag.reason || null,\n    };\n    // Note, the logic above ensures that variationIndex and reason will always be null rather than\n    // undefined if we don't have values for them. That's just to avoid subtle errors that depend on\n    // whether an object was JSON-encoded with null properties omitted or not.\n  }\n\n  function doNotTrack() {\n    let flag;\n    if (navigator && navigator.doNotTrack !== undefined) {\n      flag = navigator.doNotTrack; // FF, Chrome\n    } else if (navigator && navigator.msDoNotTrack !== undefined) {\n      flag = navigator.msDoNotTrack; // IE 9/10\n    } else {\n      flag = window.doNotTrack; // IE 11+, Safari\n    }\n    return flag === '1' || flag === 'yes';\n  }\n\n  function allFlags() {\n    const results = {};\n\n    if (!flags) {\n      return results;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key)) {\n        results[key] = variationDetailInternal(key, null, !sendEventsOnlyForVariation).value;\n      }\n    }\n\n    return results;\n  }\n\n  function customEventExists(key) {\n    if (!goals || goals.length === 0) {\n      return false;\n    }\n\n    for (let i = 0; i < goals.length; i++) {\n      if (goals[i].kind === 'custom' && goals[i].key === key) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function track(key, data) {\n    if (typeof key !== 'string') {\n      emitter.maybeReportError(new errors.LDInvalidEventKeyError(messages.unknownCustomEventKey(key)));\n      return;\n    }\n\n    // Validate key if we have goals\n    if (!!goals && !customEventExists(key)) {\n      console.warn(messages.unknownCustomEventKey(key));\n    }\n\n    enqueueEvent({\n      kind: 'custom',\n      key: key,\n      data: data,\n      user: ident.getUser(),\n      url: window.location.href,\n      creationDate: new Date().getTime(),\n    });\n  }\n\n  function connectStream() {\n    if (!ident.getUser()) {\n      return;\n    }\n    stream.connect(ident.getUser(), {\n      ping: function() {\n        requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n          if (err) {\n            emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n          }\n          updateSettings(settings);\n        });\n      },\n      put: function(e) {\n        const data = JSON.parse(e.data);\n        updateSettings(data);\n      },\n      patch: function(e) {\n        const data = JSON.parse(e.data);\n        // If both the flag and the patch have a version property, then the patch version must be\n        // greater than the flag version for us to accept the patch.  If either one has no version\n        // then the patch always succeeds.\n        const oldFlag = flags[data.key];\n        if (!oldFlag || !oldFlag.version || !data.version || oldFlag.version < data.version) {\n          const mods = {};\n          const newFlag = utils.extend({}, data);\n          delete newFlag['key'];\n          flags[data.key] = newFlag;\n          const newDetail = getFlagDetail(newFlag);\n          if (oldFlag) {\n            mods[data.key] = { previous: oldFlag.value, current: newDetail };\n          } else {\n            mods[data.key] = { current: newDetail };\n          }\n          postProcessSettingsUpdate(mods);\n        }\n      },\n      delete: function(e) {\n        const data = JSON.parse(e.data);\n        if (!flags[data.key] || flags[data.key].version < data.version) {\n          const mods = {};\n          if (flags[data.key] && !flags[data.key].deleted) {\n            mods[data.key] = { previous: flags[data.key].value };\n          }\n          flags[data.key] = { version: data.version, deleted: true };\n          postProcessSettingsUpdate(mods);\n        }\n      },\n    });\n  }\n\n  function updateSettings(newFlags) {\n    const changes = {};\n\n    if (!newFlags) {\n      return;\n    }\n\n    for (const key in flags) {\n      if (flags.hasOwnProperty(key) && flags[key]) {\n        if (newFlags[key] && newFlags[key].value !== flags[key].value) {\n          changes[key] = { previous: flags[key].value, current: getFlagDetail(newFlags[key]) };\n        } else if (!newFlags[key] || newFlags[key].deleted) {\n          changes[key] = { previous: flags[key].value };\n        }\n      }\n    }\n    for (const key in newFlags) {\n      if (newFlags.hasOwnProperty(key) && newFlags[key] && (!flags[key] || flags[key].deleted)) {\n        changes[key] = { current: getFlagDetail(newFlags[key]) };\n      }\n    }\n\n    flags = newFlags;\n    postProcessSettingsUpdate(changes);\n  }\n\n  function postProcessSettingsUpdate(changes) {\n    const keys = Object.keys(changes);\n\n    if (useLocalStorage) {\n      store.saveFlags(flags);\n    }\n\n    if (keys.length > 0) {\n      const changeEventParams = {};\n      keys.forEach(key => {\n        const current = changes[key].current;\n        const value = current ? current.value : undefined;\n        const previous = changes[key].previous;\n        emitter.emit(changeEvent + ':' + key, value, previous);\n        changeEventParams[key] = current ? { current: value, previous: previous } : { previous: previous };\n      });\n\n      emitter.emit(changeEvent, changeEventParams);\n\n      if (!sendEventsOnlyForVariation) {\n        keys.forEach(key => {\n          sendFlagEvent(key, changes[key].current);\n        });\n      }\n    }\n  }\n\n  function on(event, handler, context) {\n    if (event.substr(0, changeEvent.length) === changeEvent) {\n      subscribedToChangeEvents = true;\n      if (!stream.isConnected()) {\n        connectStream();\n      }\n      emitter.on.apply(emitter, [event, handler, context]);\n    } else {\n      emitter.on.apply(emitter, Array.prototype.slice.call(arguments));\n    }\n  }\n\n  function off(event) {\n    if (event === changeEvent) {\n      if ((subscribedToChangeEvents = true)) {\n        subscribedToChangeEvents = false;\n        stream.disconnect();\n      }\n    }\n    emitter.off.apply(emitter, Array.prototype.slice.call(arguments));\n  }\n\n  function handleMessage(event) {\n    if (event.origin !== baseUrl) {\n      return;\n    }\n    if (event.data.type === 'SYN') {\n      window.editorClientBaseUrl = baseUrl;\n      const editorTag = document.createElement('script');\n      editorTag.type = 'text/javascript';\n      editorTag.async = true;\n      editorTag.src = baseUrl + event.data.editorClientUrl;\n      const s = document.getElementsByTagName('script')[0];\n      s.parentNode.insertBefore(editorTag, s);\n    }\n  }\n\n  if (!env) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidEnvironmentIdError(messages.environmentNotSpecified()));\n    });\n  }\n\n  if (!user) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.userNotSpecified()));\n    });\n  } else if (!user.key) {\n    utils.onNextTick(() => {\n      emitter.maybeReportError(new errors.LDInvalidUserError(messages.invalidUser()));\n    });\n  }\n\n  if (typeof options.bootstrap === 'object') {\n    utils.onNextTick(signalSuccessfulInit);\n  } else if (\n    typeof options.bootstrap === 'string' &&\n    options.bootstrap.toUpperCase() === 'LOCALSTORAGE' &&\n    !!localStorage\n  ) {\n    useLocalStorage = true;\n\n    flags = store.loadFlags();\n\n    if (flags === null) {\n      flags = {};\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n          signalFailedInit(initErr);\n        } else {\n          if (settings) {\n            flags = settings;\n            store.saveFlags(flags);\n          } else {\n            flags = {};\n          }\n          signalSuccessfulInit();\n        }\n      });\n    } else {\n      // We're reading the flags from local storage. Signal that we're ready,\n      // then update localStorage for the next page load. We won't signal changes or update\n      // the in-memory flags unless you subscribe for changes\n      utils.onNextTick(signalSuccessfulInit);\n\n      requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n        if (err) {\n          emitter.maybeReportError(new errors.LDFlagFetchError(messages.errorFetchingFlags(err)));\n        }\n        if (settings) {\n          store.saveFlags(settings);\n        }\n      });\n    }\n  } else {\n    requestor.fetchFlagSettings(ident.getUser(), hash, (err, settings) => {\n      if (err) {\n        flags = {};\n        const initErr = new errors.LDFlagFetchError(messages.errorFetchingFlags(err));\n        signalFailedInit(initErr);\n      } else {\n        flags = settings || {};\n        signalSuccessfulInit();\n      }\n    });\n  }\n\n  function refreshGoalTracker() {\n    if (goalTracker) {\n      goalTracker.dispose();\n    }\n    if (goals && goals.length) {\n      goalTracker = GoalTracker(goals, sendGoalEvent);\n    }\n  }\n\n  function watchLocation(interval, callback) {\n    let previousUrl = location.href;\n    let currentUrl;\n\n    function checkUrl() {\n      currentUrl = location.href;\n\n      if (currentUrl !== previousUrl) {\n        previousUrl = currentUrl;\n        callback();\n      }\n    }\n\n    function poll(fn, interval) {\n      fn();\n      setTimeout(() => {\n        poll(fn, interval);\n      }, interval);\n    }\n\n    poll(checkUrl, interval);\n\n    if (!!(window.history && history.pushState)) {\n      window.addEventListener('popstate', checkUrl);\n    } else {\n      window.addEventListener('hashchange', checkUrl);\n    }\n  }\n\n  if (fetchGoals) {\n    requestor.fetchGoals((err, g) => {\n      if (err) {\n        emitter.maybeReportError(\n          new errors.LDUnexpectedResponseError('Error fetching goals: ' + err.message ? err.message : err)\n        );\n      }\n      if (g && g.length > 0) {\n        goals = g;\n        goalTracker = GoalTracker(goals, sendGoalEvent);\n        watchLocation(locationWatcherInterval, refreshGoalTracker);\n      }\n      emitter.emit(goalsEvent);\n    });\n  }\n\n  function signalSuccessfulInit() {\n    emitter.emit(readyEvent);\n    emitter.emit(successEvent); // allows initPromise to distinguish between success and failure\n  }\n\n  function signalFailedInit(err) {\n    emitter.maybeReportError(err);\n    emitter.emit(failedEvent, err);\n    emitter.emit(readyEvent); // for backward compatibility, this event happens even on failure\n  }\n\n  function start() {\n    if (sendEvents) {\n      events.start();\n    }\n  }\n\n  if (document.readyState !== 'complete') {\n    window.addEventListener('load', start);\n  } else {\n    start();\n  }\n\n  window.addEventListener('beforeunload', () => {\n    if (sendEvents) {\n      events.stop();\n      events.flush(true);\n    }\n  });\n\n  window.addEventListener('message', handleMessage);\n\n  const readyPromise = new Promise(resolve => {\n    const onReady = emitter.on(readyEvent, () => {\n      emitter.off(readyEvent, onReady);\n      resolve();\n    });\n  });\n\n  const goalsPromise = new Promise(resolve => {\n    const onGoals = emitter.on(goalsEvent, () => {\n      emitter.off(goalsEvent, onGoals);\n      resolve();\n    });\n  });\n\n  const initPromise = new Promise((resolve, reject) => {\n    const onSuccess = emitter.on(successEvent, () => {\n      emitter.off(successEvent, onSuccess);\n      resolve();\n    });\n    const onFailure = emitter.on(failedEvent, err => {\n      emitter.off(failedEvent, onFailure);\n      reject(err);\n    });\n  });\n\n  const client = {\n    waitForInitialization: () => initPromise,\n    waitUntilReady: () => readyPromise,\n    waitUntilGoalsReady: () => goalsPromise,\n    identify: identify,\n    variation: variation,\n    variationDetail: variationDetail,\n    track: track,\n    on: on,\n    off: off,\n    flush: flush,\n    allFlags: allFlags,\n  };\n\n  return client;\n}\n\nexport const version = VERSION;\n\nfunction deprecatedInitialize(env, user, options = {}) {\n  console && console.warn && console.warn(messages.deprecated('default export', 'named LDClient export'));\n  return initialize(env, user, options);\n}\n\nexport default { initialize: deprecatedInitialize, version };\n","import { base64URLEncode } from './utils';\n\nexport default function Stream(baseUrl, environment, hash, config) {\n  const stream = {};\n  const evalUrlPrefix = baseUrl + '/eval/' + environment + '/';\n  const useReport = (config && config.useReport) || false;\n  const withReasons = (config && config.evaluationReasons) || false;\n  const streamReconnectDelay = (config && config.streamReconnectDelay) || 1000;\n  let es = null;\n  let reconnectTimeoutReference = null;\n  let user = null;\n  let handlers = null;\n\n  stream.connect = function(newUser, newHandlers) {\n    user = newUser;\n    handlers = newHandlers;\n    tryConnect();\n  };\n\n  stream.disconnect = function() {\n    clearTimeout(reconnectTimeoutReference);\n    reconnectTimeoutReference = null;\n    close();\n  };\n\n  stream.isConnected = function() {\n    return es && (es.readyState === EventSource.OPEN || es.readyState === EventSource.CONNECTING);\n  };\n\n  function reconnect() {\n    closeConnection();\n    tryConnect(streamReconnectDelay);\n  }\n\n  function tryConnect(delay) {\n    if (!reconnectTimeoutReference) {\n      if (delay) {\n        reconnectTimeoutReference = setTimeout(openConnection, delay);\n      } else {\n        openConnection();\n      }\n    }\n  }\n\n  function openConnection() {\n    let url;\n    let query = '';\n    if (typeof EventSource !== 'undefined') {\n      if (useReport) {\n        // we don't yet have an EventSource implementation that supports REPORT, so\n        // fall back to the old ping-based stream\n        url = baseUrl + '/ping/' + environment;\n      } else {\n        url = evalUrlPrefix + base64URLEncode(JSON.stringify(user));\n        if (hash !== null && hash !== undefined) {\n          query = 'h=' + hash;\n        }\n      }\n      if (withReasons) {\n        query = query + (query ? '&' : '') + 'withReasons=true';\n      }\n      url = url + (query ? '?' : '') + query;\n\n      closeConnection();\n      es = new window.EventSource(url);\n      for (const key in handlers) {\n        if (handlers.hasOwnProperty(key)) {\n          es.addEventListener(key, handlers[key]);\n        }\n      }\n\n      es.onerror = reconnect;\n    }\n  }\n\n  function closeConnection() {\n    if (es) {\n      es.close();\n      es = null;\n    }\n  }\n\n  return stream;\n}\n","import * as messages from './messages';\nimport * as utils from './utils';\n\nexport default function Store(environment, hash, ident) {\n  const store = {};\n\n  function getFlagsKey() {\n    let key = '';\n    const user = ident.getUser();\n    if (user) {\n      key = hash || utils.btoa(JSON.stringify(user));\n    }\n    return 'ld:' + environment + ':' + key;\n  }\n\n  store.loadFlags = function() {\n    const key = getFlagsKey();\n    let dataStr, data;\n    try {\n      dataStr = localStorage.getItem(key);\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n      return null;\n    }\n    try {\n      data = JSON.parse(dataStr);\n    } catch (ex) {\n      store.clearFlags();\n      return null;\n    }\n    if (data) {\n      const schema = data.$schema;\n      if (schema === undefined || schema < 1) {\n        data = utils.transformValuesToVersionedValues(data);\n      }\n    }\n    return data;\n  };\n\n  store.saveFlags = function(flags) {\n    const key = getFlagsKey();\n    const data = utils.extend({}, flags, { $schema: 1 });\n    try {\n      localStorage.setItem(key, JSON.stringify(data));\n    } catch (ex) {\n      console.warn(messages.localStorageUnavailable());\n    }\n  };\n\n  store.clearFlags = function() {\n    const key = getFlagsKey();\n    try {\n      localStorage.removeItem(key);\n    } catch (ex) {}\n  };\n\n  return store;\n}\n"],"names":["createCustomError","name","CustomError","message","code","captureStackTrace","Error","this","constructor","prototype","LDUnexpectedResponseError","LDInvalidEnvironmentIdError","LDInvalidUserError","LDInvalidEventKeyError","LDInvalidArgumentError","LDFlagFetchError","isHttpErrorRecoverable","status","object","exports","chars","InvalidCharacterError","btoa","input","block","charCode","str","String","idx","map","output","charAt","charCodeAt","atob","replace","length","bs","buffer","bc","fromCharCode","indexOf","s","Base64","unescape","encodeURIComponent","base64URLEncode","clone","obj","JSON","parse","stringify","onNextTick","cb","wrapPromiseCallback","promise","callback","ret","then","value","Promise","reject","error","undefined","addLDHeaders","xhr","setRequestHeader","extend","objects","reduce","acc","MAX_URL_LENGTH","EventSender","eventsUrl","environmentId","forceHasCors","imageCreator","sendLDHeaders","hasCors","postUrl","imageUrl","sender","loadUrlUsingImage","src","onDone","img","Image","addEventListener","sendChunk","events","usePost","sync","createImage","jsonBody","send","createRequest","canRetry","XMLHttpRequest","open","errors","dateStr","getResponseHeader","time","Date","serverTime","getResponseInfo","utils","resolve","sendEvents","finalSync","chunks","maxLength","allEvents","slice","allChunks","remainingSpace","chunk","event","shift","unshift","push","results","i","all","docLink","localStorageUnavailable","unknownCustomEventKey","key","environmentNotFound","environmentNotSpecified","errorFetchingFlags","err","userNotSpecified","invalidUser","bootstrapOldFormat","bootstrapInvalid","deprecated","oldName","newName","httpErrorMessage","context","retryMessage","UserFilter","config","filter","allAttributesPrivate","all_attributes_private","privateAttributeNames","private_attribute_names","ignoreAttrs","custom","anonymous","allowedTopLevelAttrs","console","warn","messages","filterUser","user","userPrivateAttrs","filterAttrs","props","isAttributeAllowed","Object","keys","isPrivateAttr","result","filteredProps","removedAttrs","customResult","removedAttrNames","sort","privateAttrs","EventProcessor","es","startDate","endDate","counters","options","emitter","processor","eventSender","summarizer","summarizeEvent","kind","counterKey","variation","version","counterVal","count","default","creationDate","getSummary","flagsOut","empty","c","flag","counterOut","unknown","clearSummary","userFilter","inlineUsers","inlineUsersInEvents","queue","flushInterval","samplingInterval","lastKnownPastTime","disabled","flushTimer","reportArgumentError","maybeReportError","shouldSampleEvent","Math","floor","random","isNaN","isNan","enqueue","e","addFullEvent","addDebugEvent","trackEvents","debugEventsUntilDate","getTime","userKey","makeOutputEvent","debugEvent","flush","eventsToSend","summary","responseInfo","start","setTimeout","flushTick","stop","EventEmitter","on","handler","concat","off","emit","apply","Array","call","arguments","matchOperatorsRe","TypeError","doesUrlMatch","matcher","href","search","hash","canonicalUrl","regex","testUrl","RegExp","escapeStringRegexp","url","substring","pattern","test","GoalTracker","goals","onEvent","tracker","listenerFn","clickGoals","goal","urls","j","location","matches","target","selector","elements","document","querySelectorAll","parentNode","findGoalsForClick","dispose","removeEventListener","json","fetchJSON","endpoint","body","data","lastIndexOf","responseText","getResponseError","statusText","Identity","initialUser","onChange","ident","setUser","u","sane","toString","sanitizeUser","getUser","readyEvent","successEvent","failedEvent","changeEvent","goalsEvent","locationWatcherInterval","initialize","env","baseUrl","streamUrl","optionWithDefault","allowFrequentDuplicateEvents","sendEventsOnlyForVariation","fetchGoals","environment","stream","evalUrlPrefix","useReport","withReasons","evaluationReasons","streamReconnectDelay","reconnectTimeoutReference","handlers","reconnect","tryConnect","delay","openConnection","query","EventSource","window","hasOwnProperty","onerror","closeConnection","close","connect","newUser","newHandlers","disconnect","isConnected","readyState","OPEN","CONNECTING","Stream","eventProcessor","requestor","flagSettingsRequest","lastFlagSettingsCallback","join","currentCallback","prevCallback","wrappedCallback","abort","Requestor","seenRequests","flags","_typeof","bootstrap","metadata","forEach","readFlagsFromBootstrap","goalTracker","useLocalStorage","subscribedToChangeEvents","firstEvent","defaultVal","shouldEnqueueEvent","navigator","doNotTrack","msDoNotTrack","enqueueEvent","store","getFlagsKey","loadFlags","dataStr","localStorage","getItem","ex","clearFlags","schema","$schema","saveFlags","setItem","removeItem","Store","sendFlagEvent","detail","defaultValue","now","cacheKey","cached","variationIndex","reason","flagVersion","sendGoalEvent","variationDetailInternal","sendEvent","deleted","getFlagDetail","errorKind","connectStream","fetchFlagSettings","settings","oldFlag","mods","newFlag","newDetail","previous","current","updateSettings","newFlags","changes","postProcessSettingsUpdate","changeEventParams","refreshGoalTracker","signalSuccessfulInit","signalFailedInit","toUpperCase","g","interval","previousUrl","currentUrl","checkUrl","poll","fn","history","pushState","origin","type","editorClientBaseUrl","editorTag","createElement","async","editorClientUrl","getElementsByTagName","insertBefore","readyPromise","onReady","goalsPromise","onGoals","initPromise","onSuccess","onFailure","flagsState","customEventExists","substr"],"mappings":"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"}